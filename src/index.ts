import {
  BrowserWindow,
  Menu,
  MenuItemConstructorOptions,
  Tray,
  app,
  dialog,
  ipcMain,
  nativeImage,
  safeStorage,
  shell,
  session,
} from "electron";
import Positioner from "electron-positioner";
import AutoLaunch from "auto-launch";
import updateElectronApp from "update-electron-app";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// NEEDS TO BE THE FIRST THING IN THE FILE
if (require("electron-squirrel-startup")) {
  app.quit();
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const PRODUCTION_CONTENT_SECURITY_POLICY = [
  "default-src 'none'",
  "connect-src 'self'",
  "img-src 'self'",
  "style-src 'self' 'unsafe-inline' fonts.googleapis.com",
  "base-uri 'self'",
  "form-action 'self'",
  "font-src fonts.gstatic.com",
].join("; ");

const WEBSITE_URL = "https://getdextop.com";
const DONATE_URL = "http://tips.getdextop.com";
const CONTACT_URL = "http://contact.getdextop.com";

updateElectronApp();

type Region = "us" | "eu" | "";
export type Session = {
  email: string;
  password: string;
  region: Region;
};

export type Event =
  | { _kind: "ok" }
  | { _kind: "wrong-credentials" }
  | { _kind: "error" };

type Glucose = {
  timestamp: string;
  value: number | null;
  trend: string;
};

type Response<T = unknown> =
  | { _kind: "ok"; data: T }
  | { _kind: "error"; data: unknown }
  | { _kind: "wrong-credentials" }
  | { _kind: "fail" };

let tray: Tray | undefined;
let preferences: BrowserWindow | undefined;
let state: Session = { email: "", password: "", region: "" };
let loopId: ReturnType<typeof setInterval> | undefined;
let isAppQuitting = false;
let isFirstLaunch = true;

if (process.platform === "darwin") {
  app.dock.hide();
}

const autoLaunch = new AutoLaunch({
  name: "DexTop",
});

app.on("web-contents-created", (_event, contents) => {
  contents.on("will-navigate", (event, _navigationUrl) => {
    event.preventDefault();
  });

  contents.setWindowOpenHandler(({ url }) => {
    if (
      [new URL(CONTACT_URL).origin, new URL(DONATE_URL).origin].includes(
        new URL(url).origin
      )
    ) {
      setImmediate(() => {
        shell.openExternal(url);
      });
    }

    return { action: "deny" };
  });
});

app.whenReady().then(() => {
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": app.isPackaged
          ? [PRODUCTION_CONTENT_SECURITY_POLICY + "; script-src 'self'"]
          : [
              PRODUCTION_CONTENT_SECURITY_POLICY +
                "; script-src 'self' 'unsafe-inline' 'unsafe-eval'",
            ],
      },
    });
  });

  ipcMain.handle("start", start);

  tray = new Tray(nativeImage.createEmpty());
  const contextMenu = Menu.buildFromTemplate(menuTemplate());
  tray.setContextMenu(contextMenu);

  showPreferences();
  setWatcher();
});

const menuTemplate = (
  label?: string
): Parameters<typeof Menu.buildFromTemplate>[0] => {
  const DEFAULT: MenuItemConstructorOptions[] = [
    { label: "Preferences", click: showPreferences },
    { type: "separator" },
    {
      label: `DexTop version ${app.getVersion()}`,
      enabled: false,
    },
    {
      label: "Website",
      click: () => shell.openExternal(WEBSITE_URL),
    },
    {
      label: "Donate",
      click: () => shell.openExternal(DONATE_URL),
    },
    {
      label: "Contact",
      click: () => shell.openExternal(CONTACT_URL),
    },
    { type: "separator" },
    { role: "quit" },
  ];
  const withTimestamp: MenuItemConstructorOptions[] = label
    ? [{ label, enabled: false }, { type: "separator" }]
    : [];
  return [...withTimestamp, ...DEFAULT];
};

const showPreferences = () => {
  preferences = new BrowserWindow({
    icon: "src/images/icon.png",
    width: 350,
    height: 300,
    movable: false,
    minimizable: false,
    maximizable: false,
    alwaysOnTop: true,
    show: false,
    skipTaskbar: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      additionalArguments: [JSON.stringify(state)],
    },
  });

  if (process.platform === "darwin") {
    preferences.webContents
      .executeJavaScript("localStorage.getItem('alreadyRun')")
      .then((item) => {
        if (item) {
          return;
        }

        return dialog
          .showMessageBox({
            title: "DexTop",
            message:
              "DexTop will launch at startup. You may need to accept a permissions prompt.",
          })
          .then(() => autoLaunch.enable())
          .then(() => {
            if (!preferences) return;
            return preferences.webContents.executeJavaScript(
              "localStorage.setItem('alreadyRun', true)"
            );
          });
      });
  }

  preferences.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  retrieveSession(preferences);

  preferences.once("ready-to-show", () => {
    if (!preferences) return;

    const positioner = new Positioner(preferences);
    const { x, y } = tray
      ? positioner.calculate(
          process.platform === "darwin" ? "trayCenter" : "trayBottomCenter",
          tray.getBounds()
        )
      : { x: 0, y: 0 };
    preferences.setPosition(x, y);

    preferences.show();
  });

  app.on("before-quit", () => {
    isAppQuitting = true;
  });
  preferences.on("close", hide);
};

const hide = (event?: Electron.Event) => {
  if (event && !isAppQuitting) {
    event.preventDefault();
  }
  if (!preferences) {
    return;
  }
  preferences.removeListener("close", hide);
  preferences.hide();
  isAppQuitting = false;
};

const validateSender = (frame: Electron.WebFrameMain) => {
  return new URL(frame.url).host === new URL(MAIN_WINDOW_WEBPACK_ENTRY).host;
};

const start = async (event: Electron.IpcMainInvokeEvent, session: Session) => {
  if (!validateSender(event.senderFrame)) return null;

  if (!preferences) {
    return null;
  }

  if (loopId) {
    clearInterval(loopId);
  }
  const response = await start_(session);
  switch (response._kind) {
    case "ok":
      loopId = setInterval(() => start_(session), 1000 * 60);
      hide();
      preferences.webContents.send("startResponseReceived", response);
      preferences.webContents.executeJavaScript(
        `localStorage.setItem('session', '${JSON.stringify({
          email: session.email,
          region: session.region,
          password: encryptOr(session.password, ""),
        })}')`
      );
      return;
    case "wrong-credentials":
      preferences.webContents.send("startResponseReceived", response);
      return;
    case "error":
      preferences.webContents.send("startResponseReceived", response);
      return;
  }
};

const start_ = async (session: Session): Promise<Event> => {
  if (!tray) return { _kind: "error" };

  const glucose = await getGlucose(session);
  switch (glucose._kind) {
    case "ok": {
      const contextMenu = Menu.buildFromTemplate(
        menuTemplate(`Last glucose at ${glucose.data.timestamp}`)
      );
      tray.setContextMenu(contextMenu);
      state = { ...state, ...session };
      // const RED_FG = '\033[31;1m';
      // const RED_BG = '\033[41;1m';
      setWatcher(glucose.data);
      return { _kind: "ok" };
    }
    case "no-glucose-in-5-minutes": {
      const contextMenu = Menu.buildFromTemplate(
        menuTemplate(`No glucose in the last 5 minutes..`)
      );
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "ok" };
    }
    case "wrong-credentials": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "wrong-credentials" };
    }
    case "error": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "error" };
    }
    case "fail": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "error" };
    }
  }
};

const getGlucose = async (
  session: Session
): Promise<Response<Glucose> | { _kind: "no-glucose-in-5-minutes" }> => {
  const { email, password, region } = session;
  if (region === "") return { _kind: "fail" };
  const accountId = await getAccountId({ email, password, host: host(region) });
  if (accountId._kind !== "ok") return accountId;
  const sessionId = await getSessionId({
    accountId: accountId.data,
    password,
    host: host(region),
  });
  if (!sessionId) return { _kind: "fail" };
  const [glucose] = await getEstimatedGlucoseValues({
    sessionId,
    host: host(region),
  });
  return glucose
    ? { _kind: "ok", data: glucose }
    : { _kind: "no-glucose-in-5-minutes" };
};

const trendToIcon = (trend: string) => {
  switch (trend) {
    case "Flat":
      return "→";
    case "FortyFiveUp":
      return "↗";
    case "FortyFiveDown":
      return "↘";
    case "SingleUp":
      return "↑";
    case "SingleDown":
      return "↓";
    case "DoubleUp":
      return "⇈";
    case "DoubleDown":
      return "⇊";
    default:
      return "";
  }
};

const DEXCOM_APPLICATION_ID = "d89443d2-327c-4a6f-89e5-496bbb0317db";

const getAccountId = async ({
  email,
  password,
  host,
}: {
  email: string;
  password: string;
  host: string;
}): Promise<Response<string>> => {
  const body = {
    accountName: email,
    password,
    applicationId: DEXCOM_APPLICATION_ID,
  };
  const url = `https://${host}/ShareWebServices/Services/General/AuthenticatePublisherAccount`;
  const response = await post(body, url);
  if (response._kind !== "ok") {
    return response;
  }
  return { _kind: "ok", data: response.data as string };
};

const getSessionId = async ({
  accountId,
  password,
  host,
}: {
  accountId: string;
  password: string;
  host: string;
}): Promise<string | null> => {
  const body = {
    accountId,
    password,
    applicationId: DEXCOM_APPLICATION_ID,
  };
  const url = `https://${host}/ShareWebServices/Services/General/LoginPublisherAccountById`;
  const response = await post(body, url);
  switch (response._kind) {
    case "ok":
      return response.data as Promise<string | null>;
    case "error":
      return null;
    case "wrong-credentials":
      return null;
    case "fail":
      return null;
  }
};

const getEstimatedGlucoseValues = async ({
  sessionId,
  host,
}: {
  sessionId: string;
  host: string;
}): Promise<Glucose[]> => {
  const body = {
    maxCount: 1,
    minutes: 6,
    sessionId,
  };
  const url = `https://${host}/ShareWebServices/Services/Publisher/ReadPublisherLatestGlucoseValues`;
  const response = await post(body, url);
  if (response._kind !== "ok") {
    return [];
  }
  // The API returns something like:
  // [{
  //   "WT":"Date(1649148591000)",
  //   "ST":"Date(1649148591000)",
  //   "DT":"Date(1649148591000+0200)",
  //   "Value":116,
  //   "Trend":"Flat"
  // }]
  const data = response.data as {
    Value: number;
    Trend: string;
    DT: string;
  }[];

  const notNull = <T>(x: T | null): x is T => x !== null;

  return data
    .map((glucose) => {
      const timestamp = convertToLocalTime(glucose.DT);
      if (!timestamp) return null;
      return {
        value: glucose.Value,
        trend: glucose.Trend,
        timestamp: timestamp,
      };
    })
    .filter(notNull);
};

const post = async (
  body: Record<PropertyKey, unknown>,
  url: string
): Promise<Response> => {
  try {
    const result = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const json = await result.json();
    if (result.ok) {
      return { _kind: "ok", data: json };
    } else if ("Code" in json && json.Code == "AccountPasswordInvalid") {
      return { _kind: "wrong-credentials" };
    } else {
      return { _kind: "error", data: json };
    }
  } catch (error) {
    return { _kind: "fail" };
  }
};

const convertToLocalTime = (dt: string): string | null => {
  const [_1, epochWithTz] = dt.match(/Date\((.+)\)/) || [];
  if (!epochWithTz) return null;
  const [_2, epoch, sign, offset] = epochWithTz.match(/(\d+)([-+])(\d+)/) || [];
  if (!epoch || !sign || !offset) return null;
  const date = new Date(parseInt(epoch, 10));
  const iso =
    date.toISOString().slice(0, -1) + (sign === "-" ? "+" : "-") + offset;
  const local = new Date(iso).toISOString().slice(0, -1) + `${sign}${offset}`;
  const [_3, timestamp] = local.match(/.+T(\d\d:\d\d):.+/) || [];
  return timestamp || null;
};

const host = (region: Exclude<Region, "">): string => {
  switch (region) {
    case "us":
      return "share2.dexcom.com";
    case "eu":
      return "shareous1.dexcom.com";
  }
};

type Segment =
  | "Top"
  | "TopRight"
  | "BottomRight"
  | "Bottom"
  | "BottomLeft"
  | "TopLeft"
  | "Center";

const drawDigit = (
  segments: Segment[],
  coords: { cols: [number, number]; rows: [number, number, number] }
): string => {
  if (segments.length === 0) return "";

  const lines = segments.map((segment) => {
    switch (segment) {
      case "Top": {
        return `
          ctx.moveTo(${coords.cols[0]}, ${coords.rows[0]});
          ctx.lineTo(${coords.cols[1]}, ${coords.rows[0]});
        `;
      }

      case "Center": {
        return `
          ctx.moveTo(${coords.cols[0]}, ${coords.rows[1]});
          ctx.lineTo(${coords.cols[1]}, ${coords.rows[1]});
        `;
      }

      case "Bottom": {
        return `
          ctx.moveTo(${coords.cols[0]}, ${coords.rows[2]});
          ctx.lineTo(${coords.cols[1]}, ${coords.rows[2]});
        `;
      }

      case "TopRight": {
        return `
          ctx.moveTo(${coords.cols[1]}, ${coords.rows[0]});
          ctx.lineTo(${coords.cols[1]}, ${coords.rows[1]});
        `;
      }

      case "BottomRight": {
        return `
          ctx.moveTo(${coords.cols[1]}, ${coords.rows[1]});
          ctx.lineTo(${coords.cols[1]}, ${coords.rows[2]});
        `;
      }

      case "TopLeft": {
        return `
          ctx.moveTo(${coords.cols[0]}, ${coords.rows[0]});
          ctx.lineTo(${coords.cols[0]}, ${coords.rows[1]});
        `;
      }

      case "BottomLeft": {
        return `
          ctx.moveTo(${coords.cols[0]}, ${coords.rows[1]});
          ctx.lineTo(${coords.cols[0]}, ${coords.rows[2]});
        `;
      }
    }
  });

  return (
    `
    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    ctx.lineWidth = 3;
  ` +
    lines.join("\n") +
    `
    ctx.stroke();
  `
  );
};

const ONE: Segment[] = ["TopRight", "BottomRight"];
const TWO: Segment[] = ["Top", "TopRight", "Center", "BottomLeft", "Bottom"];
const THREE: Segment[] = ["TopRight", "BottomRight", "Top", "Center", "Bottom"];
const FOUR: Segment[] = ["TopLeft", "TopRight", "Center", "BottomRight"];
const FIVE: Segment[] = ["TopLeft", "BottomRight", "Top", "Center", "Bottom"];
const SIX: Segment[] = [
  "TopLeft",
  "BottomRight",
  "Top",
  "Center",
  "BottomLeft",
];
const SEVEN: Segment[] = ["TopRight", "BottomRight", "Top"];
const EIGHT: Segment[] = [
  "TopRight",
  "BottomRight",
  "Top",
  "Bottom",
  "TopLeft",
  "BottomLeft",
  "Center",
];
const NINE: Segment[] = [
  "TopRight",
  "BottomRight",
  "Top",
  "Bottom",
  "TopLeft",
  "Center",
];
const ZERO: Segment[] = [
  "TopRight",
  "BottomRight",
  "Top",
  "Bottom",
  "TopLeft",
  "BottomLeft",
];

const DOT: Segment[] = ["Bottom"];
const EMPTY: Segment[][] = [["Center"], ["Center"], ["Center"]];

const SEGMENTS_BY_CHAR: Record<string, Segment[]> = {
  "0": ZERO,
  "1": ONE,
  "2": TWO,
  "3": THREE,
  "4": FOUR,
  "5": FIVE,
  "6": SIX,
  "7": SEVEN,
  "8": EIGHT,
  "9": NINE,
  ".": DOT,
};

const drawIcon = (glucose?: Glucose): string => {
  return `
  canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;
  ctx = canvas.getContext("2d");
  ${toPath(glucose)}
  ${toSegmentss(glucose)
    .map((segments, i) =>
      drawDigit(segments, { cols: [1 + i * 12, 7 + i * 12], rows: [1, 11, 22] })
    )
    .join("\n")}
  canvas.toDataURL();
  `;
};

const toSegmentss = (glucose?: Glucose): Segment[][] => {
  if (!glucose) return EMPTY;
  if (!glucose.value) return EMPTY;
  return String(glucose.value)
    .split("")
    .map((x) => SEGMENTS_BY_CHAR[x] || []);
};

const toPath = (glucose?: Glucose): string => {
  if (!glucose) return "";

  return (
    `
    ctx.strokeStyle = "#fff";
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.lineWidth = 3;
  ` +
    trendPath(glucose) +
    `
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
  `
  );
};

const trendPath = (glucose: Glucose): string => {
  switch (glucose.trend) {
    case "Flat":
      return `
      ctx.moveTo(1, 30);
      ctx.lineTo(31, 30);
      ctx.moveTo(28, 28);
      ctx.lineTo(28, 32);
      ctx.lineTo(31, 30);
      `;
    case "FortyFiveUp":
      return `
      ctx.moveTo(11, 32);
      ctx.lineTo(15, 26);
      ctx.lineTo(19, 32);
      `;
    case "FortyFiveDown":
      return `
      ctx.moveTo(11, 26);
      ctx.lineTo(15, 32);
      ctx.lineTo(19, 26);
      `;
    case "SingleUp":
      return `
      ctx.moveTo(1, 32);
      ctx.lineTo(5, 26);
      ctx.lineTo(9, 32);
      ctx.moveTo(21, 32);
      ctx.lineTo(25, 26);
      ctx.lineTo(29, 32);
      `;
    case "SingleDown":
      return `
      ctx.moveTo(1, 26);
      ctx.lineTo(5, 32);
      ctx.lineTo(9, 26);
      ctx.moveTo(21, 26);
      ctx.lineTo(25, 32);
      ctx.lineTo(29, 26);
      `;
    case "DoubleUp":
      return `
      ctx.moveTo(1, 32);
      ctx.lineTo(5, 26);
      ctx.lineTo(9, 32);
      ctx.moveTo(11, 32);
      ctx.lineTo(15, 26);
      ctx.lineTo(19, 32);
      ctx.moveTo(21, 32);
      ctx.lineTo(25, 26);
      ctx.lineTo(29, 32);
      `;
    case "DoubleDown":
      return `
      ctx.moveTo(1, 26);
      ctx.lineTo(5, 32);
      ctx.lineTo(9, 26);
      ctx.moveTo(11, 26);
      ctx.lineTo(15, 32);
      ctx.lineTo(19, 26);
      ctx.moveTo(21, 26);
      ctx.lineTo(25, 32);
      ctx.lineTo(29, 26);
      `;
    default:
      return "";
  }
};

const setWatcher = (glucose?: Glucose) => {
  setText(glucose);
  setImage(glucose);
};

const setText = (glucose?: Glucose) => {
  if (!tray) return;
  const title = glucose
    ? `${glucose.value} ${trendToIcon(glucose.trend)}`
    : "---";
  if (process.platform === "darwin") {
    tray.setTitle(title);
    tray.setToolTip("DexTop");
  } else {
    tray.setToolTip(title);
  }
};

const setImage = (glucose?: Glucose) => {
  if (process.platform !== "win32") return;
  if (!preferences) return;
  preferences.webContents
    .executeJavaScript(drawIcon(glucose))
    .then((dataUrl) => {
      const icon = nativeImage.createFromDataURL(dataUrl);
      if (!tray) return;
      tray.setImage(icon);
    });
};

const encryptOr = (string: string, or: string): string => {
  try {
    return safeStorage.encryptString(string).toString("base64");
  } catch (Error) {
    return or;
  }
};

const decryptOr = (string: string | undefined, or: string): string => {
  if (!string) return or;
  const buffer = Buffer.from(string, "base64");

  try {
    return safeStorage.decryptString(buffer);
  } catch (Error) {
    return or;
  }
};

const retrieveSession = async (preferences: BrowserWindow) => {
  const shownSafeStorageWarning =
    await preferences.webContents.executeJavaScript(
      "localStorage.getItem('shownSafeStorageWarning')"
    );
  if (!shownSafeStorageWarning)
    await dialog.showMessageBox({
      title: "DexTop",
      message:
        "DexTop will save your password in safe storage. You may need to accept a permissions prompt.",
    });
  await preferences.webContents.executeJavaScript(
    "localStorage.setItem('shownSafeStorageWarning', true)"
  );
  const sessionJson = await preferences.webContents.executeJavaScript(
    "localStorage.getItem('session')"
  );
  if (!sessionJson) return;
  const session = JSON.parse(sessionJson);
  state = {
    ...session,
    password: decryptOr(session.password, ""),
  };
  if (!isFirstLaunch) return;
  isFirstLaunch = false;
  preferences.webContents.send("retrievedSession", state);
};

import {
  BrowserWindow,
  Menu,
  MenuItemConstructorOptions,
  Tray,
  app,
  dialog,
  ipcMain,
  nativeImage,
  powerMonitor,
  safeStorage,
  shell,
  session,
} from "electron";
import Positioner from "electron-positioner";
import AutoLaunch from "auto-launch";
import updateElectronApp from "update-electron-app";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// NEEDS TO BE THE FIRST THING IN THE FILE
if (require("electron-squirrel-startup")) {
  app.quit();
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const PRODUCTION_CONTENT_SECURITY_POLICY = [
  "default-src 'none'",
  "connect-src 'self'",
  "img-src 'self'",
  "style-src 'self' 'unsafe-inline' fonts.googleapis.com",
  "base-uri 'self'",
  "form-action 'self'",
  "font-src fonts.gstatic.com",
].join("; ");

const WEBSITE_URL = "https://getdextop.com";
const DONATE_URL = "http://tips.getdextop.com";
const CONTACT_URL = "http://contact.getdextop.com";

updateElectronApp();

type Region = "us" | "eu" | "";
export type Session = {
  email: string;
  password: string;
  region: Region;
};

export type Event =
  | { _kind: "ok" }
  | { _kind: "wrong-credentials" }
  | { _kind: "error" };

type Glucose = {
  date: { epoch: number; offset: { hours: number; minutes: number } };
  value: number | null;
  trend: string;
};

type Response<T = unknown> =
  | { _kind: "ok"; data: T }
  | { _kind: "error"; data: unknown }
  | { _kind: "wrong-credentials" }
  | { _kind: "retry" }
  | { _kind: "fail" };

const DEXCOM_DELAY = 20000;

let tray: Tray | undefined;
let preferences: BrowserWindow | undefined;
let state: Session = { email: "", password: "", region: "" };
let timeoutId: ReturnType<typeof setTimeout> | undefined;
let isAppQuitting = false;
let isFirstLaunch = true;

if (process.platform === "darwin") {
  app.dock.hide();
}

const autoLaunch = new AutoLaunch({
  name: "DexTop",
});

app.on("web-contents-created", (_event, contents) => {
  contents.on("will-navigate", (event, _navigationUrl) => {
    event.preventDefault();
  });

  contents.setWindowOpenHandler(({ url }) => {
    if (
      [new URL(CONTACT_URL).origin, new URL(DONATE_URL).origin].includes(
        new URL(url).origin
      )
    ) {
      setImmediate(() => {
        shell.openExternal(url);
      });
    }

    return { action: "deny" };
  });
});

app.whenReady().then(() => {
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": app.isPackaged
          ? [PRODUCTION_CONTENT_SECURITY_POLICY + "; script-src 'self'"]
          : [
              PRODUCTION_CONTENT_SECURITY_POLICY +
                "; script-src 'self' 'unsafe-inline' 'unsafe-eval'",
            ],
      },
    });
  });

  ipcMain.handle("start", start);

  powerMonitor.on("resume", () => {
    if (!timeoutId) return;
    clearTimeout(timeoutId);
    timeoutId = undefined;
    start_(state);
  });

  tray = new Tray(nativeImage.createEmpty());
  const contextMenu = Menu.buildFromTemplate(menuTemplate());
  tray.setContextMenu(contextMenu);

  tray.setToolTip("DexTop");

  // Needed to make sure the positioner places it correctly
  setTimeout(() => {
    showPreferences();
    setWatcher();
  }, 500);
});

const menuTemplate = (
  label?: string
): Parameters<typeof Menu.buildFromTemplate>[0] => {
  const DEFAULT: MenuItemConstructorOptions[] = [
    { label: "Preferences", click: showPreferences },
    { type: "separator" },
    {
      label: `DexTop version ${app.getVersion()}`,
      enabled: false,
    },
    {
      label: "Website",
      click: () => shell.openExternal(WEBSITE_URL),
    },
    {
      label: "Donate",
      click: () => shell.openExternal(DONATE_URL),
    },
    {
      label: "Contact",
      click: () => shell.openExternal(CONTACT_URL),
    },
    { type: "separator" },
    { role: "quit" },
  ];
  const withTimestamp: MenuItemConstructorOptions[] = label
    ? [{ label, enabled: false }, { type: "separator" }]
    : [];
  return [...withTimestamp, ...DEFAULT];
};

const showPreferences = () => {
  preferences = new BrowserWindow({
    icon: "src/images/icon.png",
    width: 350,
    height: 300,
    movable: false,
    minimizable: false,
    maximizable: false,
    alwaysOnTop: true,
    show: false,
    skipTaskbar: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      additionalArguments: [JSON.stringify(state)],
    },
  });

  if (process.platform === "darwin") {
    preferences.webContents
      .executeJavaScript("localStorage.getItem('alreadyRun')")
      .then((item) => {
        if (item) {
          return;
        }

        return dialog
          .showMessageBox({
            title: "DexTop",
            message:
              "DexTop will launch at startup. You may need to accept a permissions prompt.",
          })
          .then(() => autoLaunch.enable())
          .then(() => {
            if (!preferences) return;
            return preferences.webContents.executeJavaScript(
              "localStorage.setItem('alreadyRun', true)"
            );
          });
      });
  }

  preferences.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  retrieveSession(preferences);

  const positioner = new Positioner(preferences);
  const { x, y } = tray
    ? positioner.calculate(
        process.platform === "darwin" ? "trayCenter" : "trayBottomCenter",
        tray.getBounds()
      )
    : { x: 0, y: 0 };
  preferences.setPosition(x, y);

  preferences.once("ready-to-show", () => {
    if (!preferences) return;
    preferences.show();
  });

  app.on("before-quit", () => {
    isAppQuitting = true;
  });
  preferences.on("close", hide);
};

const hide = (event?: Electron.Event) => {
  if (event && !isAppQuitting) {
    event.preventDefault();
  }
  if (!preferences) {
    return;
  }
  preferences.removeListener("close", hide);
  preferences.hide();
  isAppQuitting = false;
};

const validateSender = (frame: Electron.WebFrameMain) => {
  return new URL(frame.url).host === new URL(MAIN_WINDOW_WEBPACK_ENTRY).host;
};

const start = async (event: Electron.IpcMainInvokeEvent, session: Session) => {
  if (!validateSender(event.senderFrame)) return null;

  if (!preferences) {
    return null;
  }

  if (timeoutId) {
    clearTimeout(timeoutId);
    timeoutId = undefined;
  }
  const response = await start_(session, true);
  switch (response._kind) {
    case "ok":
      hide();
      preferences.webContents.send("startResponseReceived", response);
      preferences.webContents.executeJavaScript(
        `localStorage.setItem('session', '${JSON.stringify({
          email: session.email,
          region: session.region,
          password: encryptOr(session.password, ""),
        })}')`
      );
      return;
    case "wrong-credentials":
      preferences.webContents.send("startResponseReceived", response);
      return;
    case "error":
      preferences.webContents.send("startResponseReceived", response);
      return;
  }
};

const start_ = async (session: Session, first = false): Promise<Event> => {
  if (!tray) return { _kind: "error" };

  const glucose = await getGlucose(session);
  switch (glucose._kind) {
    case "ok": {
      const contextMenu = Menu.buildFromTemplate(
        menuTemplate(`Last glucose at ${getTimestamp(glucose.data.date)}`)
      );
      tray.setContextMenu(contextMenu);
      state = { ...state, ...session };
      // const RED_FG = '\033[31;1m';
      // const RED_BG = '\033[41;1m';
      setWatcher(glucose.data);
      const delay = getDelay(glucose.data.date);
      timeoutId = setTimeout(() => start_(session), delay);
      return { _kind: "ok" };
    }
    case "no-glucose-in-5-minutes": {
      const contextMenu = Menu.buildFromTemplate(
        menuTemplate(`No glucose in the last 5 minutes..`)
      );
      tray.setContextMenu(contextMenu);
      setWatcher();
      timeoutId = setTimeout(() => start_(session), 1000 * 60);
      return { _kind: "ok" };
    }
    case "wrong-credentials": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "wrong-credentials" };
    }
    case "error": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "error" };
    }
    case "fail": {
      const contextMenu = Menu.buildFromTemplate(menuTemplate());
      tray.setContextMenu(contextMenu);
      setWatcher();
      return { _kind: "error" };
    }
    case "retry": {
      if (first) return { _kind: "error" };

      const contextMenu = Menu.buildFromTemplate(
        menuTemplate(`Lost signal. Retrying..`)
      );
      tray.setContextMenu(contextMenu);
      setWatcher();
      timeoutId = setTimeout(() => start_(session), 1000 * 60);
      return { _kind: "error" };
    }
  }
};

const getGlucose = async (
  session: Session
): Promise<Response<Glucose> | { _kind: "no-glucose-in-5-minutes" }> => {
  const { email, password, region } = session;
  if (region === "") return { _kind: "fail" };
  const accountId = await getAccountId({ email, password, host: host(region) });
  if (accountId._kind !== "ok") return accountId;
  const sessionId = await getSessionId({
    accountId: accountId.data,
    password,
    host: host(region),
  });
  if (!sessionId) return { _kind: "fail" };
  const [glucose] = await getEstimatedGlucoseValues({
    sessionId,
    host: host(region),
  });
  return glucose
    ? { _kind: "ok", data: glucose }
    : { _kind: "no-glucose-in-5-minutes" };
};

const trendToIcon = (trend: string) => {
  switch (trend) {
    case "Flat":
      return "→";
    case "FortyFiveUp":
      return "↗";
    case "FortyFiveDown":
      return "↘";
    case "SingleUp":
      return "↑";
    case "SingleDown":
      return "↓";
    case "DoubleUp":
      return "⇈";
    case "DoubleDown":
      return "⇊";
    default:
      return "";
  }
};

const DEXCOM_APPLICATION_ID = "d89443d2-327c-4a6f-89e5-496bbb0317db";

const getAccountId = async ({
  email,
  password,
  host,
}: {
  email: string;
  password: string;
  host: string;
}): Promise<Response<string>> => {
  const body = {
    accountName: email,
    password,
    applicationId: DEXCOM_APPLICATION_ID,
  };
  const url = `https://${host}/ShareWebServices/Services/General/AuthenticatePublisherAccount`;
  const response = await post(body, url);
  if (response._kind !== "ok") {
    return response;
  }
  return { _kind: "ok", data: response.data as string };
};

const getSessionId = async ({
  accountId,
  password,
  host,
}: {
  accountId: string;
  password: string;
  host: string;
}): Promise<string | null> => {
  const body = {
    accountId,
    password,
    applicationId: DEXCOM_APPLICATION_ID,
  };
  const url = `https://${host}/ShareWebServices/Services/General/LoginPublisherAccountById`;
  const response = await post(body, url);
  switch (response._kind) {
    case "ok":
      return response.data as Promise<string | null>;
    case "error":
      return null;
    case "wrong-credentials":
      return null;
    case "fail":
      return null;
    case "retry":
      return null;
  }
};

const getEstimatedGlucoseValues = async ({
  sessionId,
  host,
}: {
  sessionId: string;
  host: string;
}): Promise<Glucose[]> => {
  const body = {
    maxCount: 1,
    minutes: 6,
    sessionId,
  };
  const url = `https://${host}/ShareWebServices/Services/Publisher/ReadPublisherLatestGlucoseValues`;
  const response = await post(body, url);
  if (response._kind !== "ok") {
    return [];
  }
  // The API returns something like:
  // [{
  //   "WT":"Date(1649148591000)",
  //   "ST":"Date(1649148591000)",
  //   "DT":"Date(1649148591000+0200)",
  //   "Value":116,
  //   "Trend":"Flat"
  // }]
  const data = response.data as {
    Value: number;
    Trend: string;
    DT: string;
  }[];

  const notNull = <T>(x: T | null): x is T => x !== null;

  return data
    .map((glucose) => {
      const date = parseDate(glucose.DT);
      if (!date) return null;
      if (nextValueAt(date) < 0) return null;
      return {
        value: glucose.Value,
        trend: glucose.Trend,
        date,
      };
    })
    .filter(notNull);
};

const post = async (
  body: Record<PropertyKey, unknown>,
  url: string
): Promise<Response> => {
  try {
    const result = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const json = await result.json();
    if (result.ok) {
      return { _kind: "ok", data: json };
    } else if ("Code" in json && json.Code == "AccountPasswordInvalid") {
      return { _kind: "wrong-credentials" };
    } else {
      return { _kind: "error", data: json };
    }
  } catch (error) {
    const parsed = parseError(error);
    if (parsed.code === "ENETDOWN") return { _kind: "retry" };
    if (parsed.code === "ENOTFOUND") return { _kind: "retry" };
    if (parsed.code === "UND_ERR_CONNECT_TIMEOUT") return { _kind: "retry" };
    return { _kind: "fail" };
  }
};

const parseError = (error: unknown): { code: string } => {
  if (!error) return { code: "WHATEVER" };
  if (typeof error !== "object") return { code: "WHATEVER" };
  if (!("cause" in error)) return { code: "WHATEVER" };
  const cause = (error as { cause: Record<string, unknown> }).cause;
  return { code: (cause as { code: string }).code };
};

const parseDate = (dt: string): null | Glucose["date"] => {
  const [_1, epoch, hours, minutes] = (
    dt.match(/Date\((\d+)\+(\d\d)(\d\d)\)/) || []
  ).map((x) => parseInt(x, 10));
  if (epoch === undefined || hours === undefined || minutes === undefined) {
    return null;
  }
  return { epoch, offset: { hours, minutes } };
};

const getTimestamp = (date: Glucose["date"]): string => {
  const offset = (date.offset.hours * 60 + date.offset.minutes) * 60 * 1000;
  const local = new Date(date.epoch + offset);
  const [_, timestamp] = local.toISOString().match(/.+T(\d\d:\d\d):.+/) || [];
  return timestamp as string;
};

const host = (region: Exclude<Region, "">): string => {
  switch (region) {
    case "us":
      return "share2.dexcom.com";
    case "eu":
      return "shareous1.dexcom.com";
  }
};

const drawIcon = (glucose?: Glucose) => {
  const { value, fontSize } = format(glucose);
  return `
  canvas = document.createElement("canvas");
  canvas.width = 32;
  canvas.height = 32;
  ctx = canvas.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#fff";
  ctx.font = "${fontSize} Sofia Sans Extra Condensed";
  ctx.fillText("${value}", 0, 22);
  ${trendToPath(glucose?.trend ?? "")}
  ctx.stroke();
  ctx.fill();
  canvas.toDataURL();
  `;
};

const format = (
  glucose?: Glucose
): { value: string; fontSize: "32px" | "26px" | "20px" } => {
  if (!glucose) return { value: "...", fontSize: "32px" };
  if (!glucose.value) return { value: "...", fontSize: "32px" };
  const value = String(glucose.value).split("").slice(0, 3);
  if (value.length === 3 && value.includes("."))
    return { value: value.join(""), fontSize: "26px" };
  if (value.length === 3) return { value: value.join(""), fontSize: "20px" };
  return { value: value.join(""), fontSize: "32px" };
};

const trendToPath = (trend: string) => {
  switch (trend) {
    case "Flat":
      return `
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.moveTo(1, 28);
      ctx.lineTo(31, 28);
      ctx.moveTo(28, 26);
      ctx.lineTo(28, 30);
      ctx.lineTo(31, 28);
      ctx.closePath();
      `;
    case "FortyFiveUp":
      return `
      ctx.beginPath();
      ctx.moveTo(11, 32);
      ctx.lineTo(15, 26);
      ctx.lineTo(19, 32);
      ctx.closePath();
      `;
    case "FortyFiveDown":
      return `
      ctx.beginPath();
      ctx.moveTo(11, 26);
      ctx.lineTo(15, 32);
      ctx.lineTo(19, 26);
      ctx.closePath();
      `;
    case "SingleUp":
      return `
      ctx.beginPath();
      ctx.moveTo(1, 32);
      ctx.lineTo(5, 26);
      ctx.lineTo(9, 32);
      ctx.moveTo(21, 32);
      ctx.lineTo(25, 26);
      ctx.lineTo(29, 32);
      ctx.closePath();
      `;
    case "SingleDown":
      return `
      ctx.beginPath();
      ctx.moveTo(1, 26);
      ctx.lineTo(5, 32);
      ctx.lineTo(9, 26);
      ctx.moveTo(21, 26);
      ctx.lineTo(25, 32);
      ctx.lineTo(29, 26);
      ctx.closePath();
      `;
    case "DoubleUp":
      return `
      ctx.beginPath();
      ctx.moveTo(1, 32);
      ctx.lineTo(5, 26);
      ctx.lineTo(9, 32);
      ctx.moveTo(11, 32);
      ctx.lineTo(15, 26);
      ctx.lineTo(19, 32);
      ctx.moveTo(21, 32);
      ctx.lineTo(25, 26);
      ctx.lineTo(29, 32);
      ctx.closePath();
      `;
    case "DoubleDown":
      return `
      ctx.beginPath();
      ctx.moveTo(1, 26);
      ctx.lineTo(5, 32);
      ctx.lineTo(9, 26);
      ctx.moveTo(11, 26);
      ctx.lineTo(15, 32);
      ctx.lineTo(19, 26);
      ctx.moveTo(21, 26);
      ctx.lineTo(25, 32);
      ctx.lineTo(29, 26);
      ctx.closePath();
      `;
    default:
      return "";
  }
};

const setWatcher = (glucose?: Glucose) => {
  setTitle(glucose);
  setImage(glucose);
};

const setTitle = (glucose?: Glucose) => {
  if (process.platform !== "darwin") return;
  if (!tray) return;
  const title = glucose
    ? `${glucose.value} ${trendToIcon(glucose.trend)}`
    : "...";
  tray.setTitle(title);
};

const setImage = (glucose?: Glucose) => {
  if (process.platform !== "win32") return;
  if (!preferences) return;
  preferences.webContents
    .executeJavaScript(drawIcon(glucose))
    .then((dataUrl) => {
      const icon = nativeImage.createFromDataURL(dataUrl);
      if (!tray) return;
      tray.setImage(icon);
    });
};

const encryptOr = (string: string, or: string): string => {
  try {
    return safeStorage.encryptString(string).toString("base64");
  } catch (Error) {
    return or;
  }
};

const decryptOr = (string: string | undefined, or: string): string => {
  if (!string) return or;
  const buffer = Buffer.from(string, "base64");

  try {
    return safeStorage.decryptString(buffer);
  } catch (Error) {
    return or;
  }
};

const retrieveSession = async (preferences: BrowserWindow) => {
  const shownSafeStorageWarning =
    await preferences.webContents.executeJavaScript(
      "localStorage.getItem('shownSafeStorageWarning')"
    );
  if (!shownSafeStorageWarning)
    await dialog.showMessageBox({
      title: "DexTop",
      message:
        "DexTop will save your password in safe storage. You may need to accept a permissions prompt.",
    });
  await preferences.webContents.executeJavaScript(
    "localStorage.setItem('shownSafeStorageWarning', true)"
  );
  const sessionJson = await preferences.webContents.executeJavaScript(
    "localStorage.getItem('session')"
  );
  if (!sessionJson) return;
  const session = JSON.parse(sessionJson);
  state = {
    ...session,
    password: decryptOr(session.password, ""),
  };
  if (!isFirstLaunch) return;
  isFirstLaunch = false;
  preferences.webContents.send("retrievedSession", state);
};

const getDelay = (date: Glucose["date"]): number => {
  return Math.max(5000, nextValueAt(date));
};

const nextValueAt = (date: Glucose["date"]): number =>
  date.epoch + 60 * 5 * 1000 + DEXCOM_DELAY - Date.now();
